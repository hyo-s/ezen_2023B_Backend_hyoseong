기계어 : 컴퓨터가 이해 할 수 있는 언어 / 2진코드 / 0,1
	- 고급언어 : 사람이 이해 할 수있는 언어.
		- C , C++ , 자바 , 파이썬 , JS 등등
	- 저급언어 : 컴퓨터가 이해 할 수 있는 언어.
		- 어셈블리어
	- 실행 과정
		- 사람(문자) ---- JAVA문법 -----> 소스파일( .java ) ---컴파일--> 기계어파일( .class ) ---> 컴퓨터
	- 특징
		1. 모든 운영체제에서 실행 가능	  = JVM
			- 기계어 사용하기 때문에
		2. 객체 지향 프로그래밍
			- 부품 만들고 부품들을 연결해서 더 큰 프로그램 완성 ex) 레고
		3. 메모리 자동 정리 = JVM
			- *Garbage Collection ( GC ) : 사용하지 않는 메모리를 자동으로 초기화/제거
		4. 무료 라이브러리 풍부
			- 미리 만들어진 함수/클래스 들을 제공 함으로써 빠른개발/협업 도움 ex ) 스프링 프레임워크
	- JDK : 자바 개발 도구
		- JAVA문법 과 라이브러리 가지고 있는 파일
		- 버전 : JDK8 , JDK11 , JDK17(강의)
		- 스프링부트3.0 이상부터 JDK17 이상부터 지원 ( 단* 현재 전자정부프레임워크는 JDK1.8 다수 사용중 )
			- JDK17에 JDK8 포함
	- 텍스트 에디터
		- 각 언어별 자동완성 / 개발 도움을 주는 환경/기능
		1. Visual Studio Code ( 프론트엔드 가장 인기 )	: 프론트엔드 수업
		2. IntelliJ IDEA ( 일반기업/프리랜서 가장 인기 )	: 백엔드 수업
			- IntelliJ IDEA Ultimate : 유료버전
			- IntelliJ IDEA Community Edition : 무료 버전
				 IntelliJ IDEA Community Edition 2023.3.2 [ 강의 ]
		3. Eclipse ( 백엔드 가장 인기 )			: 전면 무료
==========================================================================================
IntelliJ IDEA Community Edition 2023.3.2
	1. 실행
	2. New project
		1. name : 프로젝트 이름 ( ezen_2023B_backend )
		2. location : 프로젝트 위치 ( \Desktop\ezen_2023B_backend )\
			- create git repository : 체크X
		3. Language : java
		4. build system : intellij
		5. JDK : corretto-17
			[최초 1번]
			1. Download jdk
			2. version : 17* , amazon , C:\Users\504-t\.jdks\corretto-17.0.9
		[ create ]

[ 필수 세팅 ]
- 1. 테마 선택
	메뉴 -> 셋팅 -> appearance -> 테마 선택.
- 2. 마우스 휠 확대/축소
	메뉴 -> 셋팅 -> ediotr -> general -> mouse control
		-> change font size with ctrl+mouse wheel -> active editors
- 3. 플러그인
	메뉴 -> 셋팅 -> 플러그인
	1. 한글패치
		Korean Language Pack

[ 자바 프로젝트 폴더 구성 ]

1. 프로젝트이름 [ ezen_2023B_backend ]
	- idea : 인텔리제이 설정파일
	- out : 컴파일/실행결과 된 파일 ( 컴퓨터 ) [ .class ]
	- src : 컴파일 실행 전 파일/소스파일 ( 개발자 )   [ .java ]
		2. 폴더/패키지 [ 해당 폴더 오른쪽클릭 -> 새로만들기 -> 패키지
		-day01
			3. 클래스[ 해당 폴더 오른쪽클릭 -> 새로만들기 -> 클래스 ]
			Step1 	[ 첫글자는 대문자!!!!! (*아닐경우 오류발생) ]


	- gitignore : git사용시 무시할 파일 ( commit 제외 )
	- 외부라이브러리[JDK17]
==========================================================================================
p.34
    - 변수 : 하나의 값을 저장할 수 있는 메모리 번지에 붙어진 이름
        - 사용하는 이유 : 하나의 값을 저장 [ 나중에 사용 가능 , 기억 ]
    - 변수 선언
        1. 타입
            - 기본자료형 8가지 존재
                - 사용하는 이유 : 단점(암기) , 장점( 데이터타입가독성 , 실수/오류 , *메모리효율성[빈공간] )
                    - 사탕 1개 선물 --> 사탕 크기 맞게 상자 골라. [ 빈 공간이 최대한 없도록 ]
                    - 숫자 10를 저장 --> 숫자10 크기 맞게 상자 골라.
                    - 데이터 1byte --> byte타입 사용. [ 다른 타입 사용해도 되지만. ]
            - 정수형 타입
                byte , short , int , long
            - 실수형 타입
                float , double
            - 불리언 타입
                boolean
            - 문자 타입 vs 문자열
                char
        2. 이름
            - 첫글자 소문자인 카멜표기법 권장 , 숫자시작x,공백x,특수문자일부만
            - 사용하는 이유 : 메모리 주소값 대신 메모리 위치를 식별하기 위해 문자로 표현
                - ( 컴퓨터는 저장시 메모리 주소값[16진수]=사람이 알기 어려워)
        3. 대입
            =
        4. 초기값
            - 타입 범위내 데이터만 저장 가능.!!! int 이면 int범위내 double이면 double 범위내.

    - 변수 선언 종류
        1. 타입 변수명              [ - 아직 메모리 할당 x -> 호출 불가능 ]
        2. 타입 변수명 = 초기값

==========================================================================================
진수 : 데이터 표현하는 진법 단위 (방법론)
    - 표현 단위 다형성.
    2진수 : 0 또는 1   <---> 이진코드 <---> 기계어
    8진수 : 0 1 2 3 4 5 6 7
    10진수 : 0 1 2 3 4 5 6 7 8 9 <---> 실생활에서 주로 사용
    16진수 : 0 1 2 3 4 5 6 7 8 9 A(10) B(11) C(12) D(13) E(14) F(15)

용량 : 데이터 크기 정보의 단위
    bit/비트 : 0 또는 1         ,   1비트 -> 01010101   -> 8비트( 비트 8칸 뜻 )
    *byte/바이트 : 비트8칸       ,   8비트 -> 1바이트     -> 1024바이트
    kb/킬로바이트 : 1024바이트    ,  1024바이트 -> 1킬로바이트 -> 1024킬로바이트
    mb/메가바이트 : 1024킬로바이트 , 1024킬로바이트 -> 1메가바이트 -> 1024메가바이트
    gb/기가바이트 : 1024메가바이트 , 1024메가바이트 -> 1기가바이트 ->



8가지 기본 자료형/타입
    [정수]
        1. byte     1바이트    -128 ~ 127
        2. short    2바이트    +-3만정도
        3. int      4바이트    +-21억정도 [ * 직접 입력한 값 -> 리터럴 ] - 정수의기본타입.
        4. long     8바이트    +-21억이상 [ * 리터럴 데이터 뒤에 l/L 붙여 long 타입을 알림 ]
            - 정수 리터럴의 기본타입은 int 이므로.
            - 기본자료형으로 표현이 불가능한 범위는 문자열타입(클래스)
    [문자/정수]
        1. char     2바이트    0 ~ 65535 , 유니코드 , ' ' 사용 ,  unsigned사용[부호를 안쓰고 양수만 사용하므로 ]
    [문자열/참조타입]
        1. String   문자길이에따름 , 참조타입/클래스 , " " 사용 , jdk13이상 """ """ 사용
    [실수]
        1. float    4바이트    7자리 유효  [ * 리터럴 데이터 뒤에 f/F 붙여 float 타입을 알림 ]
        2. double   8바이트    15자리 유효 [ * 직접 입력한 값 -> 리터럴 ] - 실수의기본타입
            - 실수 리터럴의 기본타입은 double 이므로.
            - 자바는 IEEE 754 표준 이용한 부동소수점 표현 [ 왜?? 컴퓨터는 소수점 몰라요.. ]
            - +부호  m(가수) X 10(지수)
    [논리]
        1. boolean  1바이트    [ 주의) 인터넷에 1비트 라고 적혀있는것도 있지만. 1바이트 정확하다. ]

    * 자바에서 사용하는 리터럴( 입력한 데이터 그 자체)
        - 정수(int) , 실수(double) , 논리(boolean) , 문자('') , 문자열(" ")

이스케이프/제어 문자 [ JS 동일 ]
    - \ 백슬래시 뜻함.
        " : 문자열 형식을 위한 연산기호/기능 들어감
        ' : 문자 형식을 위한 연산기호/기능 들어감
    - \" : "큰따옴표 문자형식 출력
    - \' : '작은따옴표 문자형식 출력
    - \n : 줄바꿈처리
    - \t : 탭
    - \\ : \백슬래시 문자형식 출력
    - \r : 캐리지 리턴[ 맨 앞으로 커서 이동 ]
        - 엔터기능 : \n\r

=============================================================================

    자바 타입
        1.기본타입( int , double , float 등 소문자. )
        2.참조타입( String , Scanner , System , Integer 등등 )

    기본 자료형/타입
        [정수]
            byte     1바이트    -128 ~ 127
            short    2바이트    +-3만정도
            int      4바이트    +-21억정도
            long     8바이트    +-21억이상

        [문자/정수]
            char     2바이트    0 ~ 65535

        [실수]
            float    4바이트    7자리 유효
            double   8바이트    15자리 유효

        [논리]
            boolean  1바이트

        [문자열/참조타입]
            String   문자길이에따름


    연산자
        [산술연산자]
            x + y   더하기
            x - y   빼기
            x * y   곱하기
            x / y   나누기
            x % y   나머지

        [비교연산자]
            x == y  같다
            x != y  같지않다
            x > y   초과
            x >= y  이상
            x < y   미만
            x <= y  이하

        [논리연산자]
            10 < x < 20        x>10 && y<20         그리고 AND
            y== 10 또는 == 20   y==10 ||y==20        또는 OR
            x>=30의 반대        !(x>=30)              부정

        [증감연산자]
            x++     10 출력 후 1 증가
            x       11
            ++x      1증가 후 12 출력

            x--     12 출력 후 1 감소
            x       11
            --x     1감소 후 10 출력

        [(복합)대입 연산자]
            x = 30      = 오른쪽 값을 왼쪽에 대입
            x += 10     x에 10을 더한 후에 x에 연산 결과 대입
            x -= 10     x에 10을 뺀 후에 x에 연산 결과 대입
            x *= 10     x에 10을 곱한 후에 x에 연산 결과 대입
            x /= 10     x에 10을 나눈 후에 x에 연산 결과 대입
            x %= 10     x에 10을 나눈 후 나머지를 x에 대입

        [삼항연산자]
            단일조건
                조건 ? 참:거짓
            복합조건
                조건이 2개일 경우  조건1 ? 참1 : 조건2 ? 참2 : 거짓
                조건이 3개일 경우  초건1 ? 참1 : 조건2 ? 참2 : 조건3 ? 참3 : 거짓

                    결과 = x >= 90 ? "합격" : "불합격";
                    결과2 = x >= 90 ? "A등급" : x >=80 ? "B등급" : "탈락";

        [연결연산자]
            변수 + "문자열"
            "문자열" + "문자열"
=============================================================================

스캐너 import java.util.Scanner;
    * Scanner scanner = new Scanner(System.in); *

=============================================================================
배열 : 연속된 공간에 값을 나열하고 인덱스를 부여
인덱스 : 각 항목(요소)의 값을 호출하거나 저장

특징
    * 배열에는 같은 타입의 값만 저장가능
    * 배열의 길이는 늘리거나 줄일 수 없다.
        방법 : 새로운 배열을 다시 만들고 기존 배열을 복사해서 새로운 값 대입

선언
    변수 선언
        타입 변수명;
        String array;
    배열 선언
        String[ ] array;
        String array[ ];

배열 선언 방법 1
    타입[] 배열명 = { 값0, 값1, 값2 }
    * 초기값을 알고 있을 때 사용

    배열 호출
        배열명[인덱스]
        int[] array = { 1, 2, 3}
        array[1]    // 2

배열 선언 방법 2
    타입[] 배열명 = new 타입[길이];
    int[] array = new int[3];
    * 초기값은 모르고 길이를 알고 있을 때 사용

    배열 호출
        for(int i=0; i<array.length; i++){
            System.out.printf("array[%1d] : %2f, ", i, array[i]);
        }

    new 연산자 사용시 초기값이 들어감
    * 정수:0 실수:0.0 논리:false 클래스/인터페이스:null

배열에 항목/요소 값 넣기/수정
    배열명[인덱스] = 새로운 값;
    array[i] = newvalue;

배열에 항목/요소 값 삭제
    배열명[인덱스] = 각 타입의 초기값
        array 배열이 * 정수 배열일 경우
            array[i] = 0;
        array 배열이 * 실수 배열일 경우
            array[i] = 0.0;
        array 배열이 * 논리 배열일 경우
            array[i] = false;
        array 배열이 * 클래스/인터페이스 배열일 경우
            array[i] = null;

배열의 길이를 구하는 속성
    배열명.length;

=============================================================================

    오름차순
        int temp = 0;

        if (a>b){temp=a; a=b; b=temp;}
        if (a>c){temp=a; a=c; c=temp;}
        if (b>c){temp=b; b=c; c=temp;}

        System.out.printf("오름차순 %d %d %d",a,b,c);*/

    무한루프
        boolean run = true
        while(run)
        while(true)

=============================================================================

타입 변환
    int num = 123;

    STRING -> INT   // 문자에서 정수로
        '123' -> 123
            int 변수명 = Integer.parseInt(문자)
            int number = Integer.parseInt(num)

    INT -> STRING   // 정수에서 문자로
        123 -> '123'
            String 변수명 = String.valueOf(정수가담긴변수)
            String str = String.valueOf(num)

=============================================================================

자바 데이터 타입 분류
    변수가 값 가지고 있으면 기본타입
    변수가 (객체)주소를 가지고 있으면 참조타입

    기본타입 : 리터럴(값) 자체
        정수 : byte, short, char, int, long
        실수 : float, double
        논리 : boolean

    참조타입 : 객체의 메모리 번지(주소)를 참조
        배열타입
        클래스(첫글자가 대문자) : String, Scanner, System, Math 등등
        인터페이스
        열거타입

코드파일 (.java) : 사람들이 만든 문법으로 코드 작성
            실행(컴파일) : javac : 프로그램(jdk포함)
빌드파일 (.class) : 바이트코드

JVM : 자바 가상 머신
------------------ Runtime Data Area 메모리(저장)공간 ------------------

        메소드영역             스택영역             힙영역 (객체가 생성되는 영역)
        - 클래스             - 지역변수             - 객체
        - 상수               - 기본타입             - 기본타입[ ]
                            - 참조타입              - new 연산자
                                                (공유/메모리 관리 자동 - GC)
        예)
        int a = 10;             스택영역에 'a'변수 선언하고 기본타입의 자료 10을 저장.
        String a = "사과";
                                    스택영역              힙영역
                                    'a변수'               (103번지) 문자열객체 "사과"
                                        a = 103번지           사과 in 103번지

        String a = null ;       스택영역에 'a'변수 선언하고 참조타입의 자료는 객체의 주소/번지가 없다.
        int[ ] a = new a[3];    스택영역에 'a'변수 선언하고 참조타입의 자료는 객체의 주소/번지를 참조한다.[주소 3개]
                                    스택영역                힙영역
                                    'a'변수               (101번지) 0, (102번지)0, (103번지)0
                                        a = 101번지

       String[ ] new String[3]; 스택영역에 'a'변수 선언하고 참조타입의 자료는 객체의 주소/번지를 참조한다.[주소 3개]
                                    스택영역                    힙영역
                                    'a'변수                      (101번지) null, (102번지) null, (103번지) null
                                        a = 101번지
                                만약에 각 인덱스/요소에 데이터가 대입
                                    a[0] = "유재석"; a[1] = "신동엽"; a[2] = "강호동"
                                                            힙영역
                                                            (101번지) 201번지, (102번지) 301번지, (103번지) 401번지
                                                            (201번지) 문자열객체 "유재석"
                                                            (301번지) 문자열객체 "신동엽"
                                                            (401번지) 문자열객체 "강호동"

    메소드영역
        바이트코드 파일의 내용이 저장되는 영역
    힙영역
        객체가 생성되는 영역
    스택영역
        스레드마다 스택영역 할당
        메소드 호출 할 때마다 생성되는 프레임이 저장되는 영역
        프레임 내부 로컬(지역) 변수가 있다.

    == != : 스택영역 비교
            int a = 10;                 String a = 100번지
            int b = 10;                 String b = 100번지
            int c = 20;                 String c = 100번지
                a == b true;                a == b true;
                a == c false;               a == c false;

    .equals( ) : 힙영역 비교
            a.equals(b);
            . : 접근연산자 : 주소가 있으면 그 주소(힙영역 -> 객체)로 이동해
                Scanner scanner = new Scanner(System.in)
                        1. 힙영역[102번지] 생성
               스택영역 Scanner = 102번지
               스택영역에 힙의 메모리 접근한다. scanner.nextInt( )
                    scanner(102번지).메소드/필드

=============================================================================

스레드
    메소드
        객체의 기능/역할
        클래스.메서드()
        .equals()    .println()
    리터럴
        데이터 값
        int a = 10;
        리터럴 : 10
함수

객체
참조
메소드영역
힙영역
스택영역

클래스
    설계도

=============================================================================

문자열 관련 함수

    1. 문자 추출 .charAt(인덱스);
        매개변수 : 추출문자인덱스번호
        반환값 : 추출된 문자
        반환타입 : char

    2. 문자열 길이 : 문자열.length( );
        매개변수 : 없음
        반환값 : 문자열길이
        반환타입 : int

    3. 문자열 대체 : 문자열.replace( );
        매개변수 : 변경할문자열, 새로운문자열
        반환값 : 새로운문자열
        반환타입 : String

    4. 문자열 잘라내기 : 문자열.subString( );
        매개변수 : (1)시작인덱스 (2)시작인덱스, 끝 인덱스
        반환값 : 잘라낸 문자열 추출
        반환타입 : String

    5-1 문자열 찾기 : 문자열.indexOf( );
        매개변수 : "찾을문자열"
        반환값 : 찾은 문자열의 인덱스번호
        반환타입 : int
    5-2 문자열 찾기 : 문자열.contains( );
        매개변수 : 문자열
        반환값 : True or False
        반환타입 : Boolean

    6. 문자열 분리 : 문자열.split( );
        매개변수 : 구분문자
        반환값 : 분리된문자
        반환타입 : 문자열[ ]

=============================================================================

객체지향 프로그래밍
    객체들을 먼저 만들고 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법
    객체 : 물리적으로 존재, 개념 중에서 다른 것과 식별 가능한 것
    객체 구성
        필드/속성 : 객체의 상태
        메소드/함수/동작 : 객체의 행위
                사람                          자동차
                이름, 나이 -> 필드            색깔, 속도 -> 필드
                웃다, 먹다 -> 메소드          달린다, 멈춘다 -> 메소드
    객체의 상호작용
        객체들 사이의 상호작용 수단은 메소드이다.
                사람                      키오스크
                돈 -> 필드                 제품가격 -> 필드
                        ----- 제품 / 돈 ----->
                주문선택 -> 메소드             주문처리 -> 메소드
                        <------ 주문 결과 ------
        함수
                함수호출 : 함수명( )
                상태전달 : 매개변수                 함수명(매개변수)
                결과리턴 : 호출한 곳으로 돌려주는 값   {return 값}

    객체 간의 관계
        혼자서도 가능하지만
        1. 집합관계 : 여러개 객체들로 구성된 객체
        2. 사용관계 : 객체 다른 객체를 읽거나 변경하거나 메소드 호출
        3. 상속관계 : 객체가 다른 객체에게 (필드/메소드) 물려주는 관계

    객체지향 프로그래밍의 특징
        1. 캡슐화 : 객체 내 (필드/메소드)를 외부 객체로부터 접근제한 (접근제한자 키워드)
        2. 상속 : 객체가 다른 객체에게 물려주는 행위 (상위/부모/슈퍼 객체 -> 하위/자식/서브 객체)
                    1.코드의 재사용성을 높인다 2.유지보수 최소화
        3. 다향성 : 사용방법(행위)은 동일하지만 실행 결과는 다양하게 나오는 성질
                자동차(객체)
                        무료 타이어 객체(펑크)       ----> 한국타이어 10만원
                                                        한국타이어 객체 -> 전진 : 무료타이어 조금 더 부드럽다.
                                                  ----> 금호타이어 20만원
                                                        금호타이어 객체 -> 전진 : 많이 부드럽다.
        객체와 클래스
            클래스 : 객체를 생성하며면 설계도 해당하는 클래스
            인스턴스 : 클래스로부터 생성된 객체
            인스턴스화 : 클래스로부터 객체를 만드는 과정
        클래스 선언
            접근제한자 클래스명
                1. 접근제한자 : 해당 클래스에 접근할 수 있는 권한 키워드 public
                2. 클래스명 : 첫문자를 대문자인 카멜표기법
        객체 생성
            클래스명 변수명 = new 생성자/클래스명(매개변수);
        클래스 용도
            1. 라이브러리 클래스 : 일반적인 설계도 목적
            2. 실행 클래스 : main( ) 함수 가지는 프로그램 진입점
        클래스 구성멤버
            1. 필드 : 객체에 데이터를 저장하는 공간 *단 변수와 비슷하지만 다르다.
            2. 생성자 : 객체를 생성할 때(new) 객체의 초기화 역할을 담당
            3. 메소드 : 객체가 수행할 동작

=============================================================================
프로그램 : 명령어의 집합체
프로세스 : 컴퓨터에서 실행중인 프로그램
스레드 : 프로세스마다 1개이상 필수 존재하는 흐름 읽어주는 다누이
        main( ) : main 스레드 포함
예시 공장
객체라는 제품을 만들려고함 설계도가 필요하지
클래스라는 설계도를 가지고 와서
    클래스라는 설계도를 보고 제품을 만드는 행위를 인스턴스화라고 함


    스레드1                                    힙영역                  메소드영역
        스택영역                                    객체(주소)              클래스 정보(필드, 생성자, 메소드)
            프레임1 (함수 호출)                            필드                  class Car(){
                지역변수1
                지역변수2                                                           String model
                지역변수3                                                           String color
                지역변수4                                                           int speed
                                                                                }
                    int 정수1 = 10;
                    Car car = null;             new Car( )
                                        <----       302번지
                        car = new Car( )                    model = "현대자동차"
                        car 변수에는 302번지가 들어가있음       color = "빨강"
                        car. .(온점)은 접근연산자               speed = 10;
                        car.speed           --->

                    Car car2 = new Car( )       new Car()
                                                    303번지
                        car = new Car( )                    model = "현대자동차"
                        car 변수에는 302번지가 들어가있음       color = "노랑"
                        car. .(온점)은 접근연산자 --->          speed = 0;
                        car.speed

            프레임2 (함수 호출)
            프레임3 (함수 호출)
                    int 정수2 = 10;

                    int 정수1이랑 정수2는 공유가 안됨 이유 : 프레임(함수) 단위로 나누어져 있음
                                                        내가 아는 지역변수개념

    스레드2
        스택영역

    데이터 타입
        자료형 -> 자료의 형태
        데이터는 값
        데이터를 저장하는 방식을 정한다. 너 문자로 저장할래 논리로 저장할래 정수로 저장할래
            데이터 저장? : 변수(데이터를 하나 저장할때는), 필드
                두가지로 나뉜다. 값자체, 주소참조
        기본타입    : 값자체 / 크기가 정해져 있음
            byte, short, char, int, long, float, double, boolean
        참조타입    : 주소참조 / 개발자가 설계에 따른 크기 사용하려고
            클래스(String, Scanner, System, Math, Car(정의), Student(정의), 배열타입, 인터페이스, 열거타입
=============================================================================

오버로딩
    매개변수의 타입, 개수, 순서에 따라 여러개 선언 가능
오버라이딩

=============================================================================

데이터타입
    기본타입 ( 7가지 )
        int 정수타입
    참조타입(클래스/인터페이스/배열 등등)
        클래스 만든다 -> 타입 만들기

클래스(참조)타입
    클래스 : 객체를 정의하는 틀 / 설계도 여러개 데이터 / 행위들을 형식    (메소드영역)
    객체 : 사전적인 정의(클래스)로 실제 존재하는 것을 말한다.              (힙영역)
    객체를 사용하는 이유 : 동일한 목적 하에 데이터화 행위 하나로 묶음 왜?? 편하니까
    객체 만드는 과정
        개발자(클래스 작성) ---> 인스턴스화(new) ---> 인스턴스(객체)
        무엇을 저장할지 고민

        1. 클래스작성
            class 클래스명(필드, 생성자, 메소드)
        2. 객체 생성
            new 생성자명();
        변수가 필요한 이유 : 객체를 참조하려고
            클래스 변수명 = new 생성자명()

    new 연산자
        생성자 : 객체를 생성할 때 초기화를 하는 역할 -> 클래스마다 무조건 1개 이상 존재.
                기본 생성자 : 자동으로 생성되는 생성자
                정의 생성자 : 직접 작성한 생성자
        생성자가 만들어낸 객체의 주소/참조 값을 리턴

    주의할 점
        변수 : stack영역 할당되는 메모리공간 / 함수 안에서 선언
        필드 : heap영역 할당되는 메모리공간 / 함수 밖이면서 클래스 안에서 선언

=============================================================================

p.144 데이터 타입 분류
    변수는 하나의 값을 저장 (스택영역)
        타입 변수명 = 값;
        타입 종류
            기본타입 : 값 자체 저장
                - byte short char int long float double boolean
            참조타입 : 주소 저장
                - 클래스(String, Scanner, Sysytem 등), 배열, 인터페이스, 열거

p.202 클래스
    객체 : 물리적으로 존재하거나 개념적인 것 중에서 다른것과 식별 가능한 것
        속성(필드), 동작(메소드)
        특징
            1. 캡슐화, 상속, 다형성
    클래스 : 객체를 생성할 때 필요한 설계도
    인스턴스 : 클래스로부터 생성된 객체
    클래스 구성멤버
        1. 필드 : 객체의 데이터가 저장되는 곳
            필드 vs 변수
                필드 : 클래스 { } 안에서 선언 / 객체 내부 존재 / 객체 내 외부 사용
                변수 : 함수 { } 안에서 선언 / 생성자, 메소드 호출시 존재 / 생성자, 메소드 내부에서만 사용
            필드 기본값
                정수:0 실수:0.0 논리:false 참조타입:null
            필드 호출
                객체가 없으면 호출 불가능
                도트(.)연산자 사용 : 객체명.필드

        2. 생성자 : 객체 생성 시 초기화 담당하는 곳
            new 연산은 객체를 생성한 후 연이어 생성자를 호출해서 객체를 초기화(생성시 처음 값 설정)하는 담당
                - 클래스명 변수명 = new 클래스/생성자( )
                생성자
                     - 기본생성자
                        클래스에 생성자 정의가 없을경우 자동으로 추가되는 생성자
                     - 생성자정의
                        1. 리턴타입/반환 없다
                        2. 생성자명 : 클래스명 동일
                        3. 매개변수
                        4. 목적 : 객체의 필드 초기화 및 유효성검사
                     - 생성자 오버로딩 :
                        - 매개변수의 타입, 개수, 순서가 다르게 여러 개의 생성자 선언

        3. 메소드 : 객체의 동작으로 호출 시 실행되는 블록
            메소드 선언
                1. 리턴타입 : 메소드가 실행 한 후 호출한 곳으로 전달하는 결과값의 타입, 없으면 void
                2. 메소드명 : 첫글자가 소문자인 카멜표기법 권장
                3. 매개변수 : 메소드를 호출할 때 전달한 매개값을 받기 위해
                4. 실행블록 : 메소드 호출 시 실행되는 블록
                5. 리턴값(리턴타입 void의 경우 생략 가능)
            메소드 호출
                - 객체가 없으면 호출 불가능. 단 main( ) 함수 제외
                - 도트(.)연산자를 사용 : 객체명.메소드명( )
                - 메소드 반환값을 변수 저장 : 타입변수 = 객체명.메소드명( )

=============================================================================

Arrays.toString( 배열명 )
    배열의 모든 요소들 값을 문자열로 출력해주는 함수.

=============================================================================

상속
    부모 클래스의 필드와 메소드를 자식 클래스에게 물려준다.
    사용하는 이유
        1. 이미 잘 개발된 부모 클래스를 재사용해서 만들기 때문에 중복되는 코드를 줄이고 개발 시간을 단축 시킨다.
        2. 클래스의 수정을 최소화 할 수 있다. 부모 클래스를 수정하면 자식 클래스에 수정 효과를 가져온다.

    자바에서는 자식이 부모를 선택한다.
        자식클래스 extends 부모클래스

    자바는 다중 상속을 허용하지 않는다. 즉 여러 개의 부모 클래스를 상속할 수 없다.

=============================================================================

    클래스
    ( 접근제한자 public / default ) ( final ) class 클래스명{ }

    멤버
        1. 필드
    ( 접근제한자 public / default / private / protected ) ( 정적 static / 인스턴스 ) ( final ) 타입 필드명;
        2. 생성자
    ( 접근제한자 public / default / private / protected ) 생성자( ){ }
        3. 메소드
    ( 접근제한자 public / default / private / protected ) ( 정적 static / 인스턴스 ) ( final ) 반환타입 메소드명( ){ }

=============================================================================

     객체 : (추상적) 물리적으로 존재하거나 개념적인 것 중에서 다른것과 식별 가능한 것
        속성 / 필드, 동작 / 메소드 로 구성
            공통적인 속성이나 동작은 간추려서 설계 ( 모델링 )

     클래스 : 객체를 생성할 때 필요한 설계도

     인스턴스 : (실제) 클래스로부터 생성된 객체

==============================================================================
상속
    부모가 자식에게 물려주는 행위
    객체지향에서도 부모 클래스의 필드와 메소드를 자식 클래스에게 물려줄 수 있다.
    사용목적
        1. 이미 잘 개발된 클래스를 재사용
        2. 새로운 클래스를 만들기 때문에 중복코드 줄임
        3. 개발 시간 단축
    키워드 : extends
        1. 자식/하위/서브 클래스 extends 부모/상위/메인 클래스
    사용방법
        1. 자식클래스가 부모클래스를 선택
            class 자식클래스명 extends 부모클래스명{ }
    부모 생성자 호출
        super( )
    메소드 재정의 [ 오버라이딩 ] @Override
        1.부모 메소드의 선언부 동일    2.접근제한 더 강하게 할 수 없다.
    부모 메소드 호출
        super.메소드( )
    final
        필드
        클래스 : 상속불가 클래스 만들기
            public final 클래스명( )            - 해당 클래스는 부모 클래스가 될 수 없다.
        메소드
            public final void 메소드명( ){ }    - 만일 상속 받았을 때 재정의 불가 메소드
    접근제한자
        public          : 필드, 생성자, 메소드, 클래스         : 모든구역
        private         : 필드, 생성자, 메소드                : 내부 클래스 내
        protected       : 필드, 생성자, 메소드                : 동일 패키지 + 자식객체만 사용 가능
        default         : 필드, 생성자, 메소드, 클래스         : 동일 패키지
==============================================================================
    JVM
        메소드영역                   스택영역            힙영역
        클래스정보                 지역변수(함수)      인스턴스(객체)

        CAR                                         new CAR( )
                                                        |        super()
                                                        |        super.메소드()
        SUPERCAR extends CAR                        new SUPERCAR( )

        - 자식객체를 힙 영역에 메모리를 할당할 때 힙 생성시 부모 객체 힙 영역에도 메모리를 할당한다.
==============================================================================
클래스에서 사용되는 키워드들
    접근제한자 ( public / private / protected / default )
    정적 ( static )
    최종 ( final )
    현재 객체 ( this )
    상위 객체 ( super )
    상속 ( extends )

클래스 선언
    접근제한자[ public / default ] final 클래스명 extends 상위 클래스
        1. (필수) 접근제한자를 선택한다
        2. 해당 클래스를 부모 클래스로 사용할지 여부를 선택한다.
        3. (필수) 클래스명 ( 첫글자 대문자로 하는 카멜 표기법 )
        4. 부모 클래스로 상속 받을지 선택한다.

필드 선언
    접근제한자[ public / private / protected / default ] [ static / 인스턴스 ] final 타입 [ 기본 / 참조 ] 필드명
        1. (필수) 접근제한자를 선택한다.
        2. (필수) 정적멤버와 인스턴스멤버 둘 중 하나 선택한다.
        3. 필드의 값 수정 여부를 선택한다.
        4. (필수) 기본 타입과 참조 타입 중 하나를 선택한다.
        5. (필수) 필드명 ( 첫글자를 소문자로 하는 카멜 표기법 )

생성자 선언
    오버로딩 : 매개변수의 개수 / 타입 / 순서에 따른 여러개 생성자 선언
    접근제한자[ public / private / protected / default ] 클래스명[=생성자명](매개변수){ }
        1. (필수) 접근제한자를 선택한다.
        2. (필수) 생성자명(=클래스명)은 클래스명과 동일하다.

메소드 선언
    오버로딩 : 매개변수의 개수 / 타입 / 순서에 따른 여러개 생성자 선언
    오버라이딩 : 만일 부모 클래스로부터 상속받은 메소드를 재정의
    접근제한자[ public / private / protected / default ] [ static / 인스턴스 ] final 반환타입[ 기본 / 참조 ] 메소드명(매개변수){ }
        1. (필수) 접근제한자를 선택한다.
        2. (필수) 정적멤버와 인스턴스멤버 둘 중 하나 선택한다.
        3. 자식 클래스가 메소드를 재정의(오버라이딩)를 할 수 있는지 가능 여부를 선택한다.
        4. (필수) 메소드가 종료(return)할때 반환할 값의 타입을 선택한다.
        5. (필수) 메소드명 ( 첫글자 소문자로 하는 카멜 표기법 )

==============================================================================

기본타입 변환
    자동 타입 변환
        byte -> short -> int -> long -> float -> double
        int a = 10;
        long b = a;
    강제 타입 변환
        byte <- short <- int <- long <- float <- double
        변환할 타입
        long a = 10;
        int b = (int)a;

참조타입 변환
    자바의 모든 클래스는 Object 클래스로부터 자동 상속 받는다.
    1. 자동 타입 변환
            자식 객체가 부모 타입으로 변환 시 자식 타입의 필드/메소드를 사용할 수 없다.
            단) 오버라이딩 된 메소드는 부모 타입이 아닌 자식 타입의 메소드가 우선 갖는다. 다형성
        부모 타입 = 자식 타입
        Object -> car -> superCar
                -> String
                -> Bank -> shinhanBank
                        -> kbBank
    2. 강제 타입 변환
        원래 자식 타입이였던 객체가 부모 타입으로 변환 후 다시 자식 타입으로 변환 할 때
        자식타입 = (자식타입) 부모타입
    3. 타입 확인
        instanceOf

==============================================================================
다형성 : 자동타입변환 + 메소드 오버라이딩
    자동타입변환 : 자식 타입 -> 부모 타입
    메소드 오버라이딩 : 자식타입에서 부모 타입의 메소드 재정의

필드[클래스 멤버]의 다형성
매개변수[메소드의 변수]의 다형성
    메소드 호출 정석 : 동일한 타입의 객체
        method1( 1 )            ---> void method1( int a ){ }
        method2( new Car( ) )   ---> void method2( Car car ){ }

    타입이 달라도 자식타입이면 가능하다. 왜? 자동으로 자동타입변환 적용
        method2( new sportsCar( ) ) ---> void method2( Car car ){ }
==============================================================================
클래스 : 객체를 만들기 위한 설계도
        클래스             vs          추상 클래스 ( 다형성 )
        new 가능                      new 불가능
        객체생성 O                     객체생성 X
        부 / 자식 / 객체                부모 클래스 용도
목적 :    객체 설계도                 필드 / 메소드 공통되는 특성을 추출
선언 :    class 클래스명{ }          abstract class 추상클래스명{ }
==============================================================================
객체
    물리적으로 존재하거나 개념적으로 존재하는 것 중에 식별이 가능한 것
    필드( = 저장 ) / 메소드( = 행위 / 이벤트 )를 구성
클래스
    객체를 만들기 위한 설계도
    1.라이브러리 클래스 2.실행클래스( main )
    멤버( 필드, 생성자, 메소드 ) 설계
        상속 : 필드 / 메소드 물려받는 것
            목적
            1.빠른 개발, 유지보수
            2.다형성 ( 타입변환 + 오버라이딩 )
            규모가 커지면서 클래스들의 연관성이 커지는 경우
            다형성 많이 쓰다보니 부모 메소드를 안쓰고 자식 메소드들이 재정의 하는 경우
        추상클래스 ( 통합 )
            서로 다른 여러개 클래스들의 공통적인 필드 / 메소드 추출
            객체 생성 불가능
            선언방법 abstract 클래스명{ }
            추상메소드 : 메소드의 선언부만 작성하고 구현부는 자식 클래스들이 한다.
                추상클래스에서만 가능
                abstract 반환타입 메소드명( )
인스턴스
    클래스를 이용한 객체를 실제 구현한 것
인스턴화
    인스턴스 만드는 작업 ( = new )

P.304 ( 클래스 ) 타입변환
P.312 ( 클래스 ) 다형성
-----
P.368 ( 인터페이스 ) 타입변환
P.373 ( 인터페이스 ) 다형성

(클래스 상속)
    필드의 다형성
    매개변수의 다형성
(인터페이스 구현)
    매개변수의 다형성

자바에서의 다형성

=====================================================================================

    0. Class.forName("JDBC 드라이버 클래스경로");
        해당 클래스를 찾아서 JDBC 드라이버 객체 (DriverManager) 등록한다.
    1. [클래스] DriverManager
        - 연동 성공하면 Connection 구현체(객체)를 반환한다.
        1.  연동함수
            DriverManager.getConnection("jdbc:mysql://IP주소:PORT번호/DB명","계정명","비밀번호")
            IP주소 = localhost : 현재 PC를 뜻한다.
            PORT번호 = mysql 3306 사용 권장
    2. [인터페이스] Connection
        - statement, PreparedStatement 구현 객체를 반환한다.
        1. connection.prepareStatement( SQL )
            SQL 서명/기재된 PreparedStatement 구현체 반환한다.
    3. [인터페이스] PreparedStatement
        - DDL, DML 문을 실행 할 때 사용한다.
        1. 실행
            1. insert, update, delete => executeUpdate( )
            2. select => .executeQuery( )
    4. [인터페이스] ResultSet
        - DB에서 가져온 데이터를 읽을 때 사용한다.
        1. 다음 레코드 이동
            .next( ) : 다음 레코드 이동 후 존재하면 true / 없으면 false 반환
        2. 현재 레코드에서 필드 값 호출
            .get타입( 호출할 필드순서번호 or 필드명 );
            .getString( ) : 문자타입 호출
            .getInt( ) : 정수타입 호출

=====================================================================================
            회원가입
                화면구현         : print, scanner
                가공·전달처리     : 입력/출력 데이터 유효성 검사·전달·타입변환
                비즈니스 로직     : 데이터 저장 SQL INSERT

    회원가입 MVC 패턴 설계
        1. 회원가입에 들어갈 정보 [ 테이블 설계 ]      = 원본
            회원 번호
            회원 아이디
            회원 비밀번호
            회원 전화번호
            회원 가입날짜

        2. DTO 설계                               = 원본 복사본
            회원 번호
            회원 아이디
            회원 비밀번호
            회원 전화번호
            회원 가입날짜
            + DB 없는 필드 추가 가능

        3. 메소드 설계 [ MVC ] 매개변수 / 리턴

    <회원가입 기능>
    VIEW                            CONTROLLER                      MODEL
    void signup(){ }                void signup(memberDto){ }       int signup(memberDto){ }
                ---DTO--->      전달·유효성검사          ---DTO--->                SQL
                아이디,비밀번호,전화번호                  유효성검사가 통과된 DTO
                <---int---                             <---boolean---
                0:성공 1:DB오류                         true:중복O, false:중복X
                2:아이디중복
                3~:각 필드별 유효성 검사

    <로그인 기능>
    VIEW                            CONTROLLER                      MODEL
    void login(){ }                boolean login(memberDto){ }       void login(memberDto){ }
                ---DTO--->         전달·유효성검사             ---DTO--->          SQL
                아이디,비밀번호,전화번호                       아이디,비밀번호,전화번호
                <---boolean---                              <---boolean---
                true:성공 false:실패        로그인정보         true:성공 false:실패
                                                                    int findMno(String id){ }
                                                            ---ID--->           SQL
                                          로그인 상태 로직    아이디
                                                            <---boolean---
                                                            0:없음, 1~:회원번호

    <로그아웃 기능>

MVC패턴
    소프트웨어 디자인 패턴
    관심사 분리 : 업무의 분리와 향상된 관리

    view        : 화면구현 UI           (입출력)
        DTO     : 데이터 이동 객체
    controller  : 중계역할              (VIEW와 MODEL 사이 전달, 가공)
        DTO     : 데이터 이동 객체
    model       : 데이터 비즈니스 로직    (DAO DB SQL 처리)

    DTO         : 데이터 이동 객체
    DAO         : 데이터 접근 객체

DB 설계
    회원제 게시판
    게시판 구현
        - 카테고리 CRUD, 게시물 CRUD, 댓글 CRUD
    1. DB설계 DDL작성
        - 게시물카테고리명, 게시물제목, 게시물내용, 게시물작성자, 게시물작성일, 게시물조회수, 댓글내용, 댓글작성자
    2. DTO 구현
        -
    3. MVC패턴 구현
        1. 글쓰기
        2. 모든 글 출력
        3. 개별 글 출력
        4. 글 수정
        5. 글 삭제
=====================================================================================
인터페이스 ( implements )
     - 인터페이스 만들고 구현객체 만들고 인터페이스 타입의 구현객체 생성하고 메소드 호출
    1. 두 객체를 연결하는 역할
        객체A         인터페이스           객체B
             메소드호출-->     메소드호출-->
             <--리턴값         <--리턴값
        객체 A에서 인터페이스 메소드를 호출하면 객체 B 메소드를 호출
        객체 B의 리턴값을 객체 A로 전달
        1-1 다형성
                     (추상메소드)        (오버라이딩 필수)
                                        (구현객체)
        객체A         인터페이스           객체B
                                        객체C
        객체 A는 인터페이스 메소드만 사용 // 객체 B와 객체 C가 바뀌는거 관심 X
        인터페이스의 메소드는 추상메소드 그렇기때문에 객체 B와 객체 C에서 재정의를 해줘야 한다.


    2. 인터페이스 구현, 인터페이스 활용

    3. 객체 생성 불가 ( 구현 클래스 필요 -> 재정의 메소드 필요 )
        1. 선언 : interface 인터페이스명( )
        2. 구현클래스 : class 클래스명 implements 인터페이스{ }

    4. 인터페이스 멤버
        1. 상수 필드 ( public static final -> 생략가능 ) 인스턴스 필드 불가 [ 대문자 사용 / 서로 다른 단어일 경우 (_) 언더바로 연결 ]
        2. 추상 메소드 ( public abstract -> 생략가능 ) 선언부 작성, 실행부{ } 작성 안함 오버라이딩 필수 ( 구현객체 필요 )
        3. 디폴트 메소드 ( public default ) 선언부 작성, 실행부 작성, 오버라이딩 선택 ( 구현객체 필요 )
        4. 정적 메소드 ( public static )  선언부 작성, 실행부 작성, 오버라이딩 선택 ( 구현객체 필요없음 )
        5. 프라이빗 메소드 ( private )                   : 구현 객체가 필요한 메소드
        6. 프라이빗 정적 메소드 ( private static )       : 구현 객체가 필요 없는 메소드



=====================================================================================
인텔리제이설치
MYSQL
MYSQL JAVA 연결
JAVAFX 설치

SceneBuilder 설치
=====================================================================================
p.464

    .java파일 ---실행---> .class파일
                javac

    에러 : 하드웨어 고장으로 인해 실행 오류가 발생
    예외 : (사용자가)잘못된 사용 또는 (개발자)코딩으로 인한 오류

    종류
        1. 일반예외 : 컴파일러가 예외 처리 코드 여부를 검사
            실행 전에 예외처리
        2. 실행예외 : 컴파일러가 예외 처리 코드 여부를 검사하지 않는 예외
            개발자 경험 토대로 예외처리 예상

    예외 발생하면 예외 클래스로부터 객체 (자동)생성한다.
        - 예외처리 시 사용
        - Throwable, Exception*

    표준 라이브러리
        라이브러리 : 미리 만들어진 클래스/함수 집합/모임
        예외클래스
            Exception*                                : 다중 catch 했을 때 상위 클래스 뒤에 작성한다.
            [실행예외] NullPointerException            : 변수의 참조값이 없을 때 예외 발생
            [실행예외] ArrayIndexOutOfBoundsException  : 배열의 인덱스 범위를 벗어났을 때 예외 발생
            [실행예외] NumberFormatException           : 정수타입으로 형 변환을 할 수 없을 때 예외 발생
            [일반예외] ClassNotFoundException          : 해당 클래스를 찾이 못했을 때 예외 발생
                상황에 따른 서로 다른 코드/행위 하려고

    예외처리
        try{ }                       : 예외 발생 혹은 할것 같은 코드
        catch(예외클래스 변수명){ }     : 예외 발생 했을때 코드
        finally{ }                   : 항상 실행되는 코드

        - 리소스 안전하게 닫기
            try{
                외부적인 요소와 연동
                    FileInputStream( ) 파일처리
                    DriverManager.getConnection( ) : DB연동
                    등등
            }catch(예외클래스 e){

            }finally{
                안전하게 연동된 요소와 끝마침/닫기
                close( );
            }
=====================================================================================
제네릭
    < >
    결정되지 않은 타입을 파라미터로 처리하고
    실제 사용할 때 파라미터를 구체적인 타입 대체 가능
    컬렉션 프레임워크 P.640
        자료구조( 자료를 저장하는 방법들 ) 바탕으로 객체들을 효율적으로
        추가, 삭제, 검색할 기능과 관련된 인터페이스와 클래스들
        ( 객체 수집 )
        List, Set, Map 인터페이스
            List : ArrayList, Vector, LinkedList
            Set  : HashSet, TreeSet
            Map  : HashMap, Hashtable, TreeMap, Properties
=====================================================================================
JDK : 자바 개발도구 ( JAVAC 포함, JAR 포함 )
라이브러리 : ( 도구 ) 클래스 / 인터페이스 모임
프레임워크 : ( 틀 ) 프로그램 개발하기 위해 틀을 제공하는 프로그램

SPRING : 자바를 이용한 라이브러리들의 집합들로 만든 프레임워크
SPRING BOOT : SPRING 간소화 설정

1. 프로젝트 준비
    Project : Gradle - Groovy
        Gradle : 빌드 관리 도구 VS Maven
            외부 라이브러리들을 설치하고 관리해주는 시스템
            Language : JAVA
            SPRING BOOT : 3.X [ 추후에 변경 가능 ]
            PACKAGING : JAR
            JAVA : 17 ( SPRING BOOT 3.X이상 )

2. 프로젝트 메타데이터 / 정보
    Artifact : 홈페이지 명
    Package name : 홈페이지 HTTP 주소를 반대로 ( ezen.com / com.ezen )

3. 외부 라이브러리 추가 Dependencies
        https://mvnrepository.com/ - 외부 라이브러리 공유 사이트
        1. SPRING WEB
        2. H2 Database : ( 테스트 / 간단한 개발 / 영구저장X ) DB서버없이 웹서버로 데이터 베이스 제공 < -- > MYSQL
        3. Mustache : 화면구현 ( 템플릿 엔진 )
            템플릿 엔진 : 1.JSP 2.(*)Mustache 3.Thymeleaf 4.(*)React.js 5.Vue.js
        4. SPRING DATA JPA : RDBMS를 JAVA 객체지향으로 매칭하는 도구

        MYSQL 라이브러리
            runtimeOnly 'com.mysql:mysql-connector-j'
        MUSTACHE 라이브러리
            implementation 'org.springframework.boot:spring-boot-starter-mustache'


4. 프로젝트 파일 구조
    .idea                                       : 인텔리제이 설정 파일
    Gradle                                      : 그레이들(빌드) 실행 도구
    src (*)                                     : 코드 소스 파일
        - main
            -- java                             : 자바 소스 파일
                --- 패키지
            -- resources                        : 프로젝트 설정 파일, 정적(html.css.js.img 등등) 외부 파일
                --- static                      : HTML,CSS,JS,IMG 등등
                --- templates                   : 템플릿( JSP, Mustache, Thymeleaf, React.js, Vue.js 등등 )
                --- application.properties      : 프로젝트 설정 파일
        - test                                  : 테스트 소스 파일
    gitignore                                   : git commit 무시할 파일
    build.gradle (*)                            : 프로젝트에 등록할 라이브러리
    외부라이브러리 : JDK17, 스프링부트 관련 클래스들

5. 프로젝트 실행
    톰캣 ( was : 자바 웹서버 프로그램 ) 내장 서버 : PORT 8080
    PORT 변경하는 방법
        server.properties 파일
            server.port = 사용할 PORT 번호
    - IP    : 네트워크를 사용하는 PC의 식별번호
    - PORT  : 컴퓨터 내에서 프로그램들의 식별번호
        3306 : MYSQL
        8080 : 톰캣

프로토콜 ( PROTOCOL ) 미리 만든 규약 / 약속 / 규칙 / 패턴
    HTTP ( HYPER TEXT TRANSFER PROTOCOL ), IP
        1. IP주소:PORT번호
        2. /경로 @GetMapping ("/hi")


IP 인터넷 프로토콜 ( INTERNET PROTOCOL )
    네트워크를 사용하는 컴퓨터의 고유 식별번호
        프로토콜 규칙이 있다.
            규칙
                ipv4
                    첫 자리는 127 사이 사용
                    0 ~ 255 사이 숫자로 4자리로 구성된 네자리 번호
                ipv6
                    0 ~ 255 사이 숫자로 6자리로 구성된 번호

    localhost : 내 컴퓨터 뜻 / 127.0.0.1
    내 아이피 알기 cmd -> ipconfig

PORT
    인터넷 프로토콜 내 프로세스의 식별번호
    0 ~ 65,535까지 중 사용 가능 [ 0 ~ 1023 ] 주요 통신이 이미 정해져 있음.
        - 주요
        HTTP : 80
            DNS : 도메인 네임 서비스
        HTTPS : 443
        MYSQL : 3306
    그 외 중복없이 자유적으로 할당해서 사용
        MYSQL : 3306
        톰캣 : 8080
IP와 PORT 이용한 네트워크 식별
    http://ip주소:포트번호
        http://localhost:8080
        http://127.0.0.1:8080
        httt://192.168.17.12:8080

해당 IP와 PORT 일치한 서버PC에게 자원 ( 데이터 HTML 요청하기 )

=====================================================================================
뷰 템플릿
    웹 페이지[HTML]를 하나의 틀로 만들고 변수를 삽입
    JSP, 머스테치, 타임리프 등등





=====================================================================================
SPRING
    한글 인코딩
        server.servlet.encoding.force-response=true
        메뉴 -> 도움말 -> 사용자 지정 VM 옵션 편집
            -Dfile.encoding=UTF-8
            -Dconcole.encoding=UTF-8
    MYSQL 라이브러리
        runtimeOnly 'com.mysql:mysql-connector-j'
    MUSTACHE 라이브러리
        implementation 'org.springframework.boot:spring-boot-starter-mustache'
    JQUERY
        <script src="https://code.jquery.com/jquery-latest.min.js"></script>
=====================================================================================
JAVA 프로그램 EXE 실행 파일 만들기
    [ JAR 추출 ]
    1. 해당 MAIN 실행
    2. 메뉴 -> 프로젝트 구조 -> 아티팩트 -> 추가
    3. JAR -> 종속 요소 포함 모듈에서
    4. 메인클래스에 변환할 클래스 선택 -> 확인
    5. 출력 디렉터리 : 추출한 JAR을 저장할 경로 설정 -> 확인
    6. 메뉴 -> 빌드 -> 아티팩트 빌드 -> 빌드

    [ JAR -> EXE 변환 ]
    준비물 : JDK, launch4j
    JDK : https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html
    launch4j : https://launch4j.sourceforge.net/

    [Basic]
        Output File : 변환했을 때 EXE 경로
        Jar : 변환할 JAR 파일 경로
    [Header]
        Header Type : Console
    [JRE]
        Min JRE Version : 1.8
    =================
    변환 : 메뉴 -> 톱니바퀴 아이콘 클릭 -> config 저장
=====================================================================================
컬렉션 프레임워크
    컬렉션( 수집 ), 프레임워크( 미리 만들어진 클래스/인터페이스/함수 )
    널리 사용되는 자료구조 ( 데이터 저장하는 방법론 ) 기반으로 제공한다.
    대표 List, Set, Map 인터페이스

1. List
    객체를 저장하면 인덱스가 부여되고, 중복 가능
    동기화 : 여러 스레드가 하나의 함수를 동시에 호출 했을 때 호출 순서대로 해당 함수를 끝날 때까지 점유 상태
    클래스
        ArrayList   : [배열구조] 동기화 지원 X, 주로 단일 스레드 사용
        Vector      : [배열구조] 동기화 지원 O, 주로 멀티 스레드 사용
        LinkedList  : [연결구조] 동기화 지원 X, 별도의 추가 라이브러리 이용하면 동기화가능
    순차적인 삽입은 ArrayList 권장
    빈번한 중간/특정위치 삽입과 삭제는 LinkedList 권장

    List 선언하는 방법
        E : 리스트에 저장하고싶은 객체 타입
        1. List<E> list = new ArrayList<>();
        2. List<E> list = new ArrayList<Board>();
        3.List list = new ArrayList();
        4. ArrayList<Board> list = new ArrayList<>();

    제공하는 함수
        1. 리스트객체명.add( 객체 )            : 주어진 객체를 리스트내 맨 끝에 추가
        2. 리스트객체명.add( 인덱스 , 객체 )    : 주어진 객체를 리스트내 주어진 인덱스에 추가 [ 기존 인덱스 객체 밀려남 ]
        3. 리스트객체명.set( 인덱스 , 객체 )    : 주어진 객체를 리스트내 주어진 인덱스에 바꿈 [ 기존 인덱스 객체 사라짐 ]
        4. 리스트객체명.size()                 : 리스트내 저장된 전체 객체 수를 반환
        5. 리스트객체명.get( 인덱스 )           : 주어진 인덱스에 저장된 객체를 반환
        6. 리스트객체명.contains( 객체 )        : 주어진 객체가 리스트내 저장되어 있는지 여부[T/F] 반환
        7. 리스트객체명.remove( 인덱스 )        : 주어진 인덱스에 저장된 객체를 삭제
        8. 리스트객체명.remove( 객체 )          : 주어진 객체를 삭제
        10. 리스트객체명.isEmpty()             : 리스트가 비어 있는지 확인[T/F] 반환
    순회
        1. for( int i = 0; i < list.size(); i++){ 실행문 }
        2. for( 타입 반복변수명 : 리스트/배열 ){ } : 리스트 내 순차적으로 하나씩 객체를 반복변수에 대입
        3. forEach( 반복변수 -> { 실행문1, 실행문2 }; );

1. Set
    Set 컬렉션
        저장 순서 / 인덱스 유지되지 않는다.
        중복 저장 불가, null 하나만 가능
            기본 중복검사 방식 : hashCode( ) --T/F--> equals( ) --T/F--> 중복
            단일 데이터 중복검사 문제없음
            여러개 데이터로 구성된 객체들의 중복검사 기준.
            haseCode( ), equals( ) 재정의
    Set 인터페이스
        1. 구현클래스
            HashSet
        2. 사용방법 / 메소드
            .add(객체명)      : 주어진 객체를 set 컬렉션에 저장
            .size( )         : Set 컬렉션의 총 객체 수 반환
            .iterator( )     : 반복자 객체 리턴
                Iterator<E> 객체명 = set.iterator()
                객체명.hasNext( );  : 다음 가져올 객체가 존재하면 true / 없으면 false
                객체명.next( );     : 하나의 객체를 가져온다.
                객체명.remove( );   : 가져온 객체를 삭제한다.
            .isEmpty( )      : Set 컬렉션이 비어 있는지 확인 [ T/F ]
            .clear( )        : Set 컬렉션 내 저장된 모든 객체 삭제
            .remove(객체)     : 주어진 객체를 Set 컬렉션 내 삭제
            .contains(객체)   : 주어진 객체가 Set 컬렉션 내 있는지 확인 [ T/F ]
    선언
        E : 컬렉션에 저장할 객체의 타입
        set<E> 컬렉션명 = new 구현클래스< >( );

    순회
        1. iterator() 이용
            Iterator<String> rs = set.iterator();
            while (rs.hasNext()){
                System.out.println("rs.next() = " + rs.next());
            }
        2. 향상된 for 문
            for(String s : set){ 실행문 }
        3. forEach() 이용
            forEach( s -> 실행문)
=====================================================================================
1. 개발환경 : JDK17, IntelliJ 무료버전
2. 프로젝트 생성
    Gradle : 외부 라이브러리를 자동으로 빌드
    Language : JAVA
    Spring Boot : 3.X 이상
    Project Metadata            * 프로젝트 정보
        Group           : com             * 주로 홈페이지의 URL 뒤에서부터 패키지 생성
        Artifact        : springMvcTest1
        Name            : springMvcTest1
        Description     : MvcTest   * 간단한 프로젝트 설명
        Package name    : com.springMvcTest1
        Packaging       : JAR / WAR
        Java            : 17
    Dependencies
        Spring Web      : * SPRING MVC 패턴 지원, 내장 웹 서버, 빌드
        Lombok          : * 코드 간소화, 로그
        MySQL Driver    : * DB 연동
        Mustache        : * 화면 구현 VIEW
3. 인텔리제이에서 프로젝트 열기
    1) 파일 -> 열기 -> springMvcTest1 폴더 찾아서 열기
    2) SpringMvcTest1Application 클래스 내 main 함수 실행
    3) 브라우저에서 http://localhost:8080 접속

4. DTO 설계
    MYSQL DB 생성 -> DTO 설계 -> 필드
    DTO @어노테이션
        @AllArgsConstructor
        @NoArgsConstructor
        @Getter
        @Setter
        @ToString

5. DB 연결
===============================================================================================
구글 크롬 브라우저 확장프로그램
    Talend API - HTTP 통신 TEST