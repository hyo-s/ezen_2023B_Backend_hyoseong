기계어 : 컴퓨터가 이해 할 수 있는 언어 / 2진코드 / 0,1
	- 고급언어 : 사람이 이해 할 수있는 언어.
		- C , C++ , 자바 , 파이썬 , JS 등등
	- 저급언어 : 컴퓨터가 이해 할 수 있는 언어.
		- 어셈블리어
	- 실행 과정
		- 사람(문자) ---- JAVA문법 -----> 소스파일( .java ) ---컴파일--> 기계어파일( .class ) ---> 컴퓨터
	- 특징
		1. 모든 운영체제에서 실행 가능	  = JVM
			- 기계어 사용하기 때문에
		2. 객체 지향 프로그래밍
			- 부품 만들고 부품들을 연결해서 더 큰 프로그램 완성 ex) 레고
		3. 메모리 자동 정리 = JVM
			- *Garbage Collection ( GC ) : 사용하지 않는 메모리를 자동으로 초기화/제거
		4. 무료 라이브러리 풍부
			- 미리 만들어진 함수/클래스 들을 제공 함으로써 빠른개발/협업 도움 ex ) 스프링 프레임워크
	- JDK : 자바 개발 도구
		- JAVA문법 과 라이브러리 가지고 있는 파일
		- 버전 : JDK8 , JDK11 , JDK17(강의)
		- 스프링부트3.0 이상부터 JDK17 이상부터 지원 ( 단* 현재 전자정부프레임워크는 JDK1.8 다수 사용중 )
			- JDK17에 JDK8 포함
	- 텍스트 에디터
		- 각 언어별 자동완성 / 개발 도움을 주는 환경/기능
		1. Visual Studio Code ( 프론트엔드 가장 인기 )	: 프론트엔드 수업
		2. IntelliJ IDEA ( 일반기업/프리랜서 가장 인기 )	: 백엔드 수업
			- IntelliJ IDEA Ultimate : 유료버전
			- IntelliJ IDEA Community Edition : 무료 버전
				 IntelliJ IDEA Community Edition 2023.3.2 [ 강의 ]
		3. Eclipse ( 백엔드 가장 인기 )			: 전면 무료
==========================================================================================
IntelliJ IDEA Community Edition 2023.3.2
	1. 실행
	2. New project
		1. name : 프로젝트 이름 ( ezen_2023B_backend )
		2. location : 프로젝트 위치 ( \Desktop\ezen_2023B_backend )\
			- create git repository : 체크X
		3. Language : java
		4. build system : intellij
		5. JDK : corretto-17
			[최초 1번]
			1. Download jdk
			2. version : 17* , amazon , C:\Users\504-t\.jdks\corretto-17.0.9
		[ create ]

[ 필수 세팅 ]
- 1. 테마 선택
	메뉴 -> 셋팅 -> appearance -> 테마 선택.
- 2. 마우스 휠 확대/축소
	메뉴 -> 셋팅 -> ediotr -> general -> mouse control
		-> change font size with ctrl+mouse wheel -> active editors
- 3. 플러그인
	메뉴 -> 셋팅 -> 플러그인
	1. 한글패치
		Korean Language Pack

[ 자바 프로젝트 폴더 구성 ]

1. 프로젝트이름 [ ezen_2023B_backend ]
	- idea : 인텔리제이 설정파일
	- out : 컴파일/실행결과 된 파일 ( 컴퓨터 ) [ .class ]
	- src : 컴파일 실행 전 파일/소스파일 ( 개발자 )   [ .java ]
		2. 폴더/패키지 [ 해당 폴더 오른쪽클릭 -> 새로만들기 -> 패키지
		-day01
			3. 클래스[ 해당 폴더 오른쪽클릭 -> 새로만들기 -> 클래스 ]
			Step1 	[ 첫글자는 대문자!!!!! (*아닐경우 오류발생) ]


	- gitignore : git사용시 무시할 파일 ( commit 제외 )
	- 외부라이브러리[JDK17]
==========================================================================================
p.34
    - 변수 : 하나의 값을 저장할 수 있는 메모리 번지에 붙어진 이름
        - 사용하는 이유 : 하나의 값을 저장 [ 나중에 사용 가능 , 기억 ]
    - 변수 선언
        1. 타입
            - 기본자료형 8가지 존재
                - 사용하는 이유 : 단점(암기) , 장점( 데이터타입가독성 , 실수/오류 , *메모리효율성[빈공간] )
                    - 사탕 1개 선물 --> 사탕 크기 맞게 상자 골라. [ 빈 공간이 최대한 없도록 ]
                    - 숫자 10를 저장 --> 숫자10 크기 맞게 상자 골라.
                    - 데이터 1byte --> byte타입 사용. [ 다른 타입 사용해도 되지만. ]
            - 정수형 타입
                byte , short , int , long
            - 실수형 타입
                float , double
            - 불리언 타입
                boolean
            - 문자 타입 vs 문자열
                char
        2. 이름
            - 첫글자 소문자인 카멜표기법 권장 , 숫자시작x,공백x,특수문자일부만
            - 사용하는 이유 : 메모리 주소값 대신 메모리 위치를 식별하기 위해 문자로 표현
                - ( 컴퓨터는 저장시 메모리 주소값[16진수]=사람이 알기 어려워)
        3. 대입
            =
        4. 초기값
            - 타입 범위내 데이터만 저장 가능.!!! int 이면 int범위내 double이면 double 범위내.

    - 변수 선언 종류
        1. 타입 변수명              [ - 아직 메모리 할당 x -> 호출 불가능 ]
        2. 타입 변수명 = 초기값

==========================================================================================
진수 : 데이터 표현하는 진법 단위 (방법론)
    - 표현 단위 다형성.
    2진수 : 0 또는 1   <---> 이진코드 <---> 기계어
    8진수 : 0 1 2 3 4 5 6 7
    10진수 : 0 1 2 3 4 5 6 7 8 9 <---> 실생활에서 주로 사용
    16진수 : 0 1 2 3 4 5 6 7 8 9 A(10) B(11) C(12) D(13) E(14) F(15)

용량 : 데이터 크기 정보의 단위
    bit/비트 : 0 또는 1         ,   1비트 -> 01010101   -> 8비트( 비트 8칸 뜻 )
    *byte/바이트 : 비트8칸       ,   8비트 -> 1바이트     -> 1024바이트
    kb/킬로바이트 : 1024바이트    ,  1024바이트 -> 1킬로바이트 -> 1024킬로바이트
    mb/메가바이트 : 1024킬로바이트 , 1024킬로바이트 -> 1메가바이트 -> 1024메가바이트
    gb/기가바이트 : 1024메가바이트 , 1024메가바이트 -> 1기가바이트 ->



8가지 기본 자료형/타입
    [정수]
        1. byte     1바이트    -128 ~ 127
        2. short    2바이트    +-3만정도
        3. int      4바이트    +-21억정도 [ * 직접 입력한 값 -> 리터럴 ] - 정수의기본타입.
        4. long     8바이트    +-21억이상 [ * 리터럴 데이터 뒤에 l/L 붙여 long 타입을 알림 ]
            - 정수 리터럴의 기본타입은 int 이므로.
            - 기본자료형으로 표현이 불가능한 범위는 문자열타입(클래스)
    [문자/정수]
        1. char     2바이트    0 ~ 65535 , 유니코드 , ' ' 사용 ,  unsigned사용[부호를 안쓰고 양수만 사용하므로 ]
    [문자열/참조타입]
        1. String   문자길이에따름 , 참조타입/클래스 , " " 사용 , jdk13이상 """ """ 사용
    [실수]
        1. float    4바이트    7자리 유효  [ * 리터럴 데이터 뒤에 f/F 붙여 float 타입을 알림 ]
        2. double   8바이트    15자리 유효 [ * 직접 입력한 값 -> 리터럴 ] - 실수의기본타입
            - 실수 리터럴의 기본타입은 double 이므로.
            - 자바는 IEEE 754 표준 이용한 부동소수점 표현 [ 왜?? 컴퓨터는 소수점 몰라요.. ]
            - +부호  m(가수) X 10(지수)
    [논리]
        1. boolean  1바이트    [ 주의) 인터넷에 1비트 라고 적혀있는것도 있지만. 1바이트 정확하다. ]

    * 자바에서 사용하는 리터럴( 입력한 데이터 그 자체)
        - 정수(int) , 실수(double) , 논리(boolean) , 문자('') , 문자열(" ")

이스케이프/제어 문자 [ JS 동일 ]
    - \ 백슬래시 뜻함.
        " : 문자열 형식을 위한 연산기호/기능 들어감
        ' : 문자 형식을 위한 연산기호/기능 들어감
    - \" : "큰따옴표 문자형식 출력
    - \' : '작은따옴표 문자형식 출력
    - \n : 줄바꿈처리
    - \t : 탭
    - \\ : \백슬래시 문자형식 출력
    - \r : 캐리지 리턴[ 맨 앞으로 커서 이동 ]
        - 엔터기능 : \n\r

=============================================================================

    자바 타입
        1.기본타입( int , double , float 등 소문자. )
        2.참조타입( String , Scanner , System , Integer 등등 )

    기본 자료형/타입
        [정수]
            byte     1바이트    -128 ~ 127
            short    2바이트    +-3만정도
            int      4바이트    +-21억정도
            long     8바이트    +-21억이상

        [문자/정수]
            char     2바이트    0 ~ 65535

        [실수]
            float    4바이트    7자리 유효
            double   8바이트    15자리 유효

        [논리]
            boolean  1바이트

        [문자열/참조타입]
            String   문자길이에따름


    연산자
        [산술연산자]
            x + y   더하기
            x - y   빼기
            x * y   곱하기
            x / y   나누기
            x % y   나머지

        [비교연산자]
            x == y  같다
            x != y  같지않다
            x > y   초과
            x >= y  이상
            x < y   미만
            x <= y  이하

        [논리연산자]
            10 < x < 20        x>10 && y<20         그리고 AND
            y== 10 또는 == 20   y==10 ||y==20        또는 OR
            x>=30의 반대        !(x>=30)              부정

        [증감연산자]
            x++     10 출력 후 1 증가
            x       11
            ++x      1증가 후 12 출력

            x--     12 출력 후 1 감소
            x       11
            --x     1감소 후 10 출력

        [(복합)대입 연산자]
            x = 30      = 오른쪽 값을 왼쪽에 대입
            x += 10     x에 10을 더한 후에 x에 연산 결과 대입
            x -= 10     x에 10을 뺀 후에 x에 연산 결과 대입
            x *= 10     x에 10을 곱한 후에 x에 연산 결과 대입
            x /= 10     x에 10을 나눈 후에 x에 연산 결과 대입
            x %= 10     x에 10을 나눈 후 나머지를 x에 대입

        [삼항연산자]
            단일조건
                조건 ? 참:거짓
            복합조건
                조건이 2개일 경우  조건1 ? 참1 : 조건2 ? 참2 : 거짓
                조건이 3개일 경우  초건1 ? 참1 : 조건2 ? 참2 : 조건3 ? 참3 : 거짓

                    결과 = x >= 90 ? "합격" : "불합격";
                    결과2 = x >= 90 ? "A등급" : x >=80 ? "B등급" : "탈락";

        [연결연산자]
            변수 + "문자열"
            "문자열" + "문자열"
=============================================================================

스캐너 import java.util.Scanner;
    * Scanner scanner = new Scanner(System.in); *

=============================================================================
배열 : 연속된 공간에 값을 나열하고 인덱스를 부여
인덱스 : 각 항목(요소)의 값을 호출하거나 저장

특징
    * 배열에는 같은 타입의 값만 저장가능
    * 배열의 길이는 늘리거나 줄일 수 없다.
        방법 : 새로운 배열을 다시 만들고 기존 배열을 복사해서 새로운 값 대입

선언
    변수 선언
        타입 변수명;
        String array;
    배열 선언
        String[ ] array;
        String array[ ];

배열 선언 방법 1
    타입[] 배열명 = { 값0, 값1, 값2 }
    * 초기값을 알고 있을 때 사용

    배열 호출
        배열명[인덱스]
        int[] array = { 1, 2, 3}
        array[1]    // 2

배열 선언 방법 2
    타입[] 배열명 = new 타입[길이];
    int[] array = new int[3];
    * 초기값은 모르고 길이를 알고 있을 때 사용

    배열 호출
        for(int i=0; i<array.length; i++){
            System.out.printf("array[%1d] : %2f, ", i, array[i]);
        }

    new 연산자 사용시 초기값이 들어감
    * 정수:0 실수:0.0 논리:false 클래스/인터페이스:null

배열에 항목/요소 값 넣기/수정
    배열명[인덱스] = 새로운 값;
    array[i] = newvalue;

배열에 항목/요소 값 삭제
    배열명[인덱스] = 각 타입의 초기값
        array 배열이 * 정수 배열일 경우
            array[i] = 0;
        array 배열이 * 실수 배열일 경우
            array[i] = 0.0;
        array 배열이 * 논리 배열일 경우
            array[i] = false;
        array 배열이 * 클래스/인터페이스 배열일 경우
            array[i] = null;

배열의 길이를 구하는 속성
    배열명.length;

=============================================================================

    오름차순
        int temp = 0;

        if (a>b){temp=a; a=b; b=temp;}
        if (a>c){temp=a; a=c; c=temp;}
        if (b>c){temp=b; b=c; c=temp;}

        System.out.printf("오름차순 %d %d %d",a,b,c);*/

    무한루프
        boolean run = true
        while(run)
        while(true)

=============================================================================

타입 변환
    int num = 123;

    STRING -> INT   // 문자에서 정수로
        '123' -> 123
            int 변수명 = Integer.parseInt(문자)
            int number = Integer.parseInt(num)

    INT -> STRING   // 정수에서 문자로
        123 -> '123'
            String 변수명 = String.valueOf(정수가담긴변수)
            String str = String.valueOf(num)

=============================================================================

자바 데이터 타입 분류
    변수가 값 가지고 있으면 기본타입
    변수가 (객체)주소를 가지고 있으면 참조타입

    기본타입 : 리터럴(값) 자체
        정수 : byte, short, char, int, long
        실수 : float, double
        논리 : boolean

    참조타입 : 객체의 메모리 번지(주소)를 참조
        배열타입
        클래스(첫글자가 대문자) : String, Scanner, System, Math 등등
        인터페이스
        열거타입

코드파일 (.java) : 사람들이 만든 문법으로 코드 작성
            실행(컴파일) : javac : 프로그램(jdk포함)
빌드파일 (.class) : 바이트코드

JVM : 자바 가상 머신
------------------ Runtime Data Area 메모리(저장)공간 ------------------

        메소드영역             스택영역             힙영역 (객체가 생성되는 영역)
        - 클래스             - 지역변수             - 객체
        - 상수               - 기본타입             - 기본타입[ ]
                            - 참조타입              - new 연산자
                                                (공유/메모리 관리 자동 - GC)
        예)
        int a = 10;             스택영역에 'a'변수 선언하고 기본타입의 자료 10을 저장.
        String a = "사과";
                                    스택영역              힙영역
                                    'a변수'               (103번지) 문자열객체 "사과"
                                        a = 103번지           사과 in 103번지

        String a = null ;       스택영역에 'a'변수 선언하고 참조타입의 자료는 객체의 주소/번지가 없다.
        int[ ] a = new a[3];    스택영역에 'a'변수 선언하고 참조타입의 자료는 객체의 주소/번지를 참조한다.[주소 3개]
                                    스택영역                힙영역
                                    'a'변수               (101번지) 0, (102번지)0, (103번지)0
                                        a = 101번지

       String[ ] new String[3]; 스택영역에 'a'변수 선언하고 참조타입의 자료는 객체의 주소/번지를 참조한다.[주소 3개]
                                    스택영역                    힙영역
                                    'a'변수                      (101번지) null, (102번지) null, (103번지) null
                                        a = 101번지
                                만약에 각 인덱스/요소에 데이터가 대입
                                    a[0] = "유재석"; a[1] = "신동엽"; a[2] = "강호동"
                                                            힙영역
                                                            (101번지) 201번지, (102번지) 301번지, (103번지) 401번지
                                                            (201번지) 문자열객체 "유재석"
                                                            (301번지) 문자열객체 "신동엽"
                                                            (401번지) 문자열객체 "강호동"

    메소드영역
        바이트코드 파일의 내용이 저장되는 영역
    힙영역
        객체가 생성되는 영역
    스택영역
        스레드마다 스택영역 할당
        메소드 호출 할 때마다 생성되는 프레임이 저장되는 영역
        프레임 내부 로컬(지역) 변수가 있다.

    == != : 스택영역 비교
            int a = 10;                 String a = 100번지
            int b = 10;                 String b = 100번지
            int c = 20;                 String c = 100번지
                a == b true;                a == b true;
                a == c false;               a == c false;

    .equals( ) : 힙영역 비교
            a.equals(b);
            . : 접근연산자 : 주소가 있으면 그 주소(힙영역 -> 객체)로 이동해
                Scanner scanner = new Scanner(System.in)
                        1. 힙영역[102번지] 생성
               스택영역 Scanner = 102번지
               스택영역에 힙의 메모리 접근한다. scanner.nextInt( )
                    scanner(102번지).메소드/필드

=============================================================================

스레드
    메소드
        객체의 기능/역할
        클래스.메서드()
        .equals()    .println()
    리터럴
        데이터 값
        int a = 10;
        리터럴 : 10
함수

객체
참조
메소드영역
힙영역
스택영역

클래스
    설계도

=============================================================================

문자열 관련 함수

    1. 문자 추출 .charAt(인덱스);
        매개변수 : 추출문자인덱스번호
        반환값 : 추출된 문자
        반환타입 : char

    2. 문자열 길이 : 문자열.length( );
        매개변수 : 없음
        반환값 : 문자열길이
        반환타입 : int

    3. 문자열 대체 : 문자열.replace( );
        매개변수 : 변경할문자열, 새로운문자열
        반환값 : 새로운문자열
        반환타입 : String

    4. 문자열 잘라내기 : 문자열.subString( );
        매개변수 : (1)시작인덱스 (2)시작인덱스, 끝 인덱스
        반환값 : 잘라낸 문자열 추출
        반환타입 : String

    5-1 문자열 찾기 : 문자열.indexOf( );
        매개변수 : "찾을문자열"
        반환값 : 찾은 문자열의 인덱스번호
        반환타입 : int
    5-2 문자열 찾기 : 문자열.contains( );
        매개변수 : 문자열
        반환값 : True or False
        반환타입 : Boolean

    6. 문자열 분리 : 문자열.split( );
        매개변수 : 구분문자
        반환값 : 분리된문자
        반환타입 : 문자열[ ]

=============================================================================

객체지향 프로그래밍
    객체들을 먼저 만들고 객체들을 하나씩 조립해서 완성된 프로그램을 만드는 기법
    객체 : 물리적으로 존재, 개념 중에서 다른 것과 식별 가능한 것
    객체 구성
        필드/속성 : 객체의 상태
        메소드/함수/동작 : 객체의 행위
                사람                          자동차
                이름, 나이 -> 필드            색깔, 속도 -> 필드
                웃다, 먹다 -> 메소드          달린다, 멈춘다 -> 메소드
    객체의 상호작용
        객체들 사이의 상호작용 수단은 메소드이다.
                사람                      키오스크
                돈 -> 필드                 제품가격 -> 필드
                        ----- 제품 / 돈 ----->
                주문선택 -> 메소드             주문처리 -> 메소드
                        <------ 주문 결과 ------
        함수
                함수호출 : 함수명( )
                상태전달 : 매개변수                 함수명(매개변수)
                결과리턴 : 호출한 곳으로 돌려주는 값   {return 값}

    객체 간의 관계
        혼자서도 가능하지만
        1. 집합관계 : 여러개 객체들로 구성된 객체
        2. 사용관계 : 객체 다른 객체를 읽거나 변경하거나 메소드 호출
        3. 상속관계 : 객체가 다른 객체에게 (필드/메소드) 물려주는 관계

    객체지향 프로그래밍의 특징
        1. 캡슐화 : 객체 내 (필드/메소드)를 외부 객체로부터 접근제한 (접근제한자 키워드)
        2. 상속 : 객체가 다른 객체에게 물려주는 행위 (상위/부모/슈퍼 객체 -> 하위/자식/서브 객체)
                    1.코드의 재사용성을 높인다 2.유지보수 최소화
        3. 다향성 : 사용방법(행위)은 동일하지만 실행 결과는 다양하게 나오는 성질
                자동차(객체)
                        무료 타이어 객체(펑크)       ----> 한국타이어 10만원
                                                        한국타이어 객체 -> 전진 : 무료타이어 조금 더 부드럽다.
                                                  ----> 금호타이어 20만원
                                                        금호타이어 객체 -> 전진 : 많이 부드럽다.
        객체와 클래스
            클래스 : 객체를 생성하며면 설계도 해당하는 클래스
            인스턴스 : 클래스로부터 생성된 객체
            인스턴스화 : 클래스로부터 객체를 만드는 과정
        클래스 선언
            접근제한자 클래스명
                1. 접근제한자 : 해당 클래스에 접근할 수 있는 권한 키워드 public
                2. 클래스명 : 첫문자를 대문자인 카멜표기법
        객체 생성
            클래스명 변수명 = new 생성자/클래스명(매개변수);
        클래스 용도
            1. 라이브러리 클래스 : 일반적인 설계도 목적
            2. 실행 클래스 : main( ) 함수 가지는 프로그램 진입점
        클래스 구성멤버
            1. 필드 : 객체에 데이터를 저장하는 공간 *단 변수와 비슷하지만 다르다.
            2. 생성자 : 객체를 생성할 때(new) 객체의 초기화 역할을 담당
            3. 메소드 : 객체가 수행할 동작

=============================================================================
프로그램 : 명령어의 집합체
프로세스 : 컴퓨터에서 실행중인 프로그램
스레드 : 프로세스마다 1개이상 필수 존재하는 흐름 읽어주는 다누이
        main( ) : main 스레드 포함
예시 공장
객체라는 제품을 만들려고함 설계도가 필요하지
클래스라는 설계도를 가지고 와서
    클래스라는 설계도를 보고 제품을 만드는 행위를 인스턴스화라고 함


    스레드1                                    힙영역                  메소드영역
        스택영역                                    객체(주소)              클래스 정보(필드, 생성자, 메소드)
            프레임1 (함수 호출)                            필드                  class Car(){
                지역변수1
                지역변수2                                                           String model
                지역변수3                                                           String color
                지역변수4                                                           int speed
                                                                                }
                    int 정수1 = 10;
                    Car car = null;             new Car( )
                                        <----       302번지
                        car = new Car( )                    model = "현대자동차"
                        car 변수에는 302번지가 들어가있음       color = "빨강"
                        car. .(온점)은 접근연산자               speed = 10;
                        car.speed           --->

                    Car car2 = new Car( )       new Car()
                                                    303번지
                        car = new Car( )                    model = "현대자동차"
                        car 변수에는 302번지가 들어가있음       color = "노랑"
                        car. .(온점)은 접근연산자 --->          speed = 0;
                        car.speed

            프레임2 (함수 호출)
            프레임3 (함수 호출)
                    int 정수2 = 10;

                    int 정수1이랑 정수2는 공유가 안됨 이유 : 프레임(함수) 단위로 나누어져 있음
                                                        내가 아는 지역변수개념

    스레드2
        스택영역

    데이터 타입
        자료형 -> 자료의 형태
        데이터는 값
        데이터를 저장하는 방식을 정한다. 너 문자로 저장할래 논리로 저장할래 정수로 저장할래
            데이터 저장? : 변수(데이터를 하나 저장할때는), 필드
                두가지로 나뉜다. 값자체, 주소참조
        기본타입    : 값자체 / 크기가 정해져 있음
            byte, short, char, int, long, float, double, boolean
        참조타입    : 주소참조 / 개발자가 설계에 따른 크기 사용하려고
            클래스(String, Scanner, System, Math, Car(정의), Student(정의), 배열타입, 인터페이스, 열거타입
=============================================================================
오버로딩
    매개변수의 타입, 개수, 순서에 따라 여러개 선언 가능
오버라이딩

=============================================================================
데이터타입
    기본타입 ( 7가지 )
        int 정수타입
    참조타입(클래스/인터페이스/배열 등등)
        클래스 만든다 -> 타입 만들기

클래스(참조)타입
    클래스 : 객체를 정의하는 틀 / 설계도 여러개 데이터 / 행위들을 형식    (메소드영역)
    객체 : 사전적인 정의(클래스)로 실제 존재하는 것을 말한다.              (힙영역)
    객체를 사용하는 이유 : 동일한 목적 하에 데이터화 행위 하나로 묶음 왜?? 편하니까
    객체 만드는 과정
        개발자(클래스 작성) ---> 인스턴스화(new) ---> 인스턴스(객체)
        무엇을 저장할지 고민

        1. 클래스작성
            class 클래스명(필드, 생성자, 메소드)
        2. 객체 생성
            new 생성자명();
        변수가 필요한 이유 : 객체를 참조하려고
            클래스 변수명 = new 생성자명()

    new 연산자
        생성자 : 객체를 생성할 때 초기화를 하는 역할 -> 클래스마다 무조건 1개 이상 존재.
                기본 생성자 : 자동으로 생성되는 생성자
                정의 생성자 : 직접 작성한 생성자
        생성자가 만들어낸 객체의 주소/참조 값을 리턴

    주의할 점
        변수 : stack영역 할당되는 메모리공간 / 함수 안에서 선언
        필드 : heap영역 할당되는 메모리공간 / 함수 밖이면서 클래스 안에서 선언

